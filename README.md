# 1주차 과제
## 주제: TDD로 개발하기
> 일정: 2024년 12월 14일 ~ 20일

[Wiki](https://github.com/han-chunsik/hhplus-w01/wiki)  
[과제 개요](https://github.com/han-chunsik/hhplus-w01/wiki/%EA%B3%BC%EC%A0%9C-%EA%B0%9C%EC%9A%94)  
[프로젝트 템플릿 분석](https://github.com/han-chunsik/hhplus-w01/wiki/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%B6%84%EC%84%9D)  
[요건 정의](https://github.com/han-chunsik/hhplus-w01/wiki/%EC%9A%94%EA%B1%B4-%EC%A0%95%EC%9D%98)
---
# 동시성 제어 방식에 대한 분석 및 보고서

# 동시성 제어
## 정의
- 동시성 제어는 여러 쓰레드나 프로세스가 같은 자원에 동시에 접근할 때 발생할 수 있는 충돌이나 문제를 방지하는 방법

## 필요성
- 데이터의 일관성과 무결성을 유지하기 위함
    - 충돌 방지: 한 쓰레드가 작업을 완료할 때까지 다른 쓰레드가 자원에 접근하지 못하게 함
    - 일관성 보장: 작업이 정확히 한 번씩만 처리되도록 보장
    - 신뢰성 유지: 결과가 정확하도록 보장

## 동시성 제어를 하지 않으면 발생할 수 있는 문제
### Race Condition
> 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태
- 두 요청이 동시에 들어와서 충전을 시도한다고 가정 했을때, 요청 A와 요청 B가 동시에 데이터에 접근 할 경우 다음과 같은 문제 발생  
  **시작 상태**
    ```
    현재 포인트: 1000
    요청 A: +500 충전
    요청 B: +500 충전
    ```
  **충전 과정에서 문제 발생**
    ```
    요청 A: 현재 포인트를 읽음 (1000)
    요청 B: 현재 포인트를 읽음 (1000)
    요청 A: 1000 + 500 = 1500으로 계산하고 저장
    요청 B: 1000 + 500 = 1500으로 계산하고 저장
    ```
  **최종 결과**
    - 요청 A와 B가 모두 1500을 저장하게 되면서, **포인트가 올바르게 증가하지 않고 한 번의 충전만 반영**된 것처럼 보여짐

## 이번 과제에서 고려해야 할 동시성 제어 요건
1. 단일 서버 환경
2. 각 유저의 요청은 순차적으로 처리: 각 유저가 보내는 요청은 순차적으로 처리되어야 함
3. 유저 간 독립성 보장: 유저 간의 요청은 독립적으로 처리되어야 하며, 한 유저의 요청이 다른 유저의 요청을 기다리지 않아야 함

## 단일 서버 환경에서 쓰레드 기반 동시성 제어 설계

### 쓰레드 기반 자바 동시성 제어 주요 방법
**1. synchronized**
- 특징: 한 번에 하나의 쓰레드만 특정 코드에 접근할 수 있도록 자동으로 락을 걸어줌.
- 장점: 코드가 간단하고 요청 순서를 보장하여 안정적인 처리 가능.
- 단점: 성능 저하, 락이 직렬화되어 다른 요청들이 대기하게 되며, 교착 상태가 발생할 수 있음.

**2. ReentrantLock**
- 특징: 명시적으로 lock()과 unlock()을 사용해 락을 제어, 공정성(Fairness) 설정을 통해 요청 순서를 보장할 수 있음.
- 장점: 유저별로 독립적인 락을 생성하고 세밀한 락 제어가 가능. tryLock()을 사용해 데드락을 방지할 수 있음.
- 단점: 락 해제를 명시적으로 해야 하므로 관리가 복잡하고, 유저 수가 많으면 메모리 사용량이 증가할 수 있음.

**3. ConcurrentHashMap**
- 특징: 내부적으로 데이터를 버킷 단위로 나누어 락을 걸어 다중 쓰레드 환경에서 안전한 데이터 읽기/쓰기를 가능하게 함.
- 장점: 높은 동시성을 제공하며, 유저별 데이터 관리가 용이.
- 단점: 요청 순서를 보장하지 않으므로, 순차적인 처리가 필요한 경우엔 적합하지 않음.

**4. ConcurrentLinkedQueue**
- 특징: 비블로킹 큐로, FIFO(First In First Out) 순서대로 작업을 처리. 락 없이 CAS(Compare-And-Swap) 방식을 사용.
- 장점: 여러 쓰레드가 동시에 큐에 안전하게 접근하여 고성능 동시성 처리가 가능.
- 단점: 순차적인 연산보다는 병렬 처리에 적합하며, 특정 위치의 데이터에 접근하거나 검색하는 데는 비효율적.

## 결론

| 방법                     | 각 유저의 요청 순차 처리 | 유저 간 독립성 보장 | 설명                                                       |
|----------|-------------------------|---------------------|----------------------------------------------------------|
| **synchronized**        | ✅                    | ❌               | - 유저 내 요청은 순차적으로 처리됨. <br> - 모든 요청이 직렬화되어 유저 간 독립적 처리가 불가. |
| **ReentrantLock**       | ✅                    | ✅                | - 유저 내 요청 순차 처리 가능. <br> - 유저별 락을 생성하여 유저 간 독립적 요청 처리 가능. |
| **ConcurrentHashMap**   | ✅                    | ✅                | - 유저 내 요청 순차 처리 가능. <br> - 유저별 락 객체 관리로 유저 간 독립적 처리 가능. |
| **ConcurrentLinkedQueue**| ❌                  | ✅                | - 큐 방식은 순차 처리 보장이 어려움. <br> - 유저별 큐로 독립적 처리 가능. |

### ReentrantLock + ConcurrentHashMap
> 순차성 보장은 락으로, 락 관리는 해시맵으로

ReentrantLock은 유저별 요청 순차성 보장을 위해, ConcurrentHashMap은 유저별 락 객체 관리 및 독립적인 요청 처리를 위해 함께 사용
- 유저 별 요청 순차성 보장을 위해 ReentrantLock로 유저별 락 생성
- 여러 유저의 요청을 독립적으로 처리하기 위해 ConcurrentHashMap을 사용하여 ReentrantLock 객체 관리

## 구현
### 락 객체 관리
- 유저의 ID를 키로, ReentrantLock을 값으로 관리하는 ConcurrentHashMap<Long, ReentrantLock>을 사용.
- computeIfAbsent 메서드를 통해 유저 ID에 해당하는 락 객체가 없으면 새로 생성하여 추가.

### 유저별 락을 통한 순차 처리
- 각 유저의 요청은 락을 얻은 후 순차적으로 처리되며, 작업이 끝나면 락을 해제 (lock.unlock()).
- 요청이 완료될 때까지 다른 요청은 대기하도록 순차적으로 처리.

### 락의 독립성 보장
- 각 유저는 독립적으로 락을 관리하므로, 유저 A의 요청이 유저 B의 요청을 기다리지 않음.
- 유저별 락을 사용하여 유저 간 요청이 독립적으로 처리되며 동시성 문제가 발생하지 않음.

### 예외 처리
- 예외가 발생한 경우에도 finally 블록에서 락을 반드시 해제하여, 시스템이 정상적으로 동작하도록 보장.

# 통합 테스트 시나리오
## 1. Race Condition, 요청 순차 처리 테스트
> 목표: 여러 요청을 보낼 때, 각 요청의 순차성이 보장되는지 확인.

**시나리오**
- 유저 A가 충전, 사용, 조회, 히스토리 조회를 포함한 요청을 보냄.
- 각 요청이 순차적으로 처리 되었는지 확인
- 유저 A의 현재 포인트 상태와 히스토리 내역을 확인하여, 처리 과정이 정상적으로 이루어졌는지 검증.

## 2. 유저 독립성 테스트
> 목표: 유저 A의 작업이 병목 현상으로 오래 걸릴 때, 유저 B의 요청이 영향을 받지 않고 정상적으로 처리되는지 확인.

**시나리오**
- 유저 A의 포인트 충전 요청 과정 중 병목 현상이 발생하도록 설정.
- 유저 B는 유저 A의 작업과 동시에 포인트 사용 요청을 보냄.
- 유저 A의 요청이 오래 걸리더라도 유저 B의 요청은 지연되지 않고 정상적으로 처리되는지 확인.
- 유저 A와 B의 히스토리 내역을 확인하여, B의 요청이 선행되었는지 검증
 
